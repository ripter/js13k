function t(t,e,n=void 0){const s=function(t){const e=/(\w+)|\[(\d+)\]/g,n=[];let s;for(;s=e.exec(t);)s[1]?n.push(s[1]):s[2]&&n.push(parseInt(s[2]));return n}(e);let a=t;for(const t of s){if(void 0===a[t])return n;a=a[t]}return a}function e(e,n){const s=t(e,n);if(!s)throw new Error(`Invalid path: ${n}`);s.dice=[],function(t,e){let n=[];for(let s=0;s<t;s++)n.push(Math.floor(Math.random()*e));return n}(s.population,e.numberOfSidesOnDice).forEach((t=>{s.food&&s.water&&(s.food--,s.water--,s.dice.push(t))}))}async function n(t){try{const e=await fetch(t);if(!e.ok)throw new Error(`HTTP error! Status: ${e.status}`);return await e.json()}catch(e){throw new Error(`Failed to fetch JSON from ${t}: ${e.message}`)}}async function s(s,a){const{src:i,description:c}=a;Object.assign(s,await n(`tribes/${i}`)),s.numberOfSidesOnDice=s.diceValues.length,s.player.dice=[],s.opponents=[],s.currentActorPath="player",s.seasonCount=1,s.gameLog=[],await async function(t,e){const{player:n}=t;t.opponents=[];for(let s=0;s<e;s++){const e=JSON.parse(JSON.stringify(n));e.name="Opponent",t.opponents.push(e)}}(s,1),await async function(s){const{deck:a,diceValues:i,seasonCount:c,opponents:o}=s,r=Math.floor(Math.random()*a.length),l=a.splice(r,1)[0],d=await n(`cards/${l.src}`);d.matches.forEach(((t,e)=>{t.claimedBy=!1,t.key=""+e})),e(s,"player"),o.forEach(((t,n)=>e(s,`opponents[${n}]`)));const h=t(s,s.currentActorPath),p=h.dice;return s.gameLog.push({actorPath:"player",season:c,description:`As the Season starts, ${h.name} arrive at ${l.name}.\n    With a ${s.name} population of ${h.population}, you start with ${p.map((t=>i[t])).join(", ")} resources.\n    `}),o.forEach(((t,e)=>{s.gameLog.push({actorPath:`opponents.${e}`,season:c,description:`An opponent arrives at ${l.name}.\n      With a ${s.name} population of ${t.population}, they start with ${t.dice.map((t=>i[t])).join(", ")} resources.\n      `})})),s.card=d,s}(s)}let a={};async function i(t){var e;await t(a),e=a,window.elmPanelCard.render(e),window.elmPanelInfo.render(e),window.elmPanelOpponent.render(e),window.elmPanelPlayer.render(e),window.elmScenarioPicker.render(e)}window.gameState=a;const c="expanded",o="option-selected";class r extends HTMLElement{constructor(){super(),this._options=[]}connectedCallback(){this.render(),this.addEventListener("click",this.handleClick)}disconnectedCallback(){this.removeEventListener("click",this.handleClick)}get options(){return this._options}set options(t){this._options=t,this.render()}get selectedOption(){const t=this.querySelector(`.option.${c}`);if(!t)return null;const e=Number(t.dataset.idx);return this.options[e]}async render(t){if(t&&t.name)return this.innerHTML="";const e=this._options.map(((t,e)=>`<div class="option" data-idx="${e}">\n        <dt>${t.name}</dt>\n        <dd>\n          ${t.description}\n          <button>üöÄ Embark</button>\n        </dd>\n      </div>`)).join("");this.innerHTML=`<dl>\n      ${e}\n    </dl>`}handleClick(t){const{target:e}=t,n=e.closest(".option");if(!n)return;const s="BUTTON"===e.tagName,a=n.classList.contains(c);s?this.dispatchEvent(new CustomEvent(o,{detail:this.selectedOption})):(this.querySelectorAll(".option.expanded").forEach((t=>t.classList.remove(c))),a||n.classList.add(c))}}customElements.define("scenario-picker",r);const l={Pray:"üôè",Gather:"üéí",Explore:"üë£",Attack:"‚öîÔ∏è"};class d extends HTMLElement{constructor(){super(),this._value=null}connectedCallback(){this.render()}static get observedAttributes(){return["value"]}attributeChangedCallback(t,e,n){"value"===t&&this.render()}get value(){return this.getAttribute("value")}render(){const{value:t}=this;this.innerHTML=`<span class="icon icon-dice">${l[t]||"‚ùì"}</span>`}}customElements.define("dice-icon",d);class h extends HTMLElement{constructor(){super()}static get observedAttributes(){return["values","selected"]}attributeChangedCallback(t,e,n){e!==n&&this.render()}connectedCallback(){this.render()}get values(){return(this.getAttribute("values")||"").split(",").map((t=>t.trim()))}get selected(){return(this.getAttribute("selected")||"").split(",").map((t=>t.trim()))}render(){const{values:t}=this,e=[...this.selected];let n=t.map((t=>{const n=e.findIndex((e=>e===t)),s=-1!==n,a=s?"":"inverted";return s&&e.splice(n,1),`<dice-icon class="${a}" value="${t}"></dice-icon>`})).join("");this.innerHTML=`<div class="dice-list">\n      ${n}\n    </div>`}}function p(t,e){let n=[...e];for(let e=0;e<t.length;e++){const s=n.indexOf(t[e]);if(-1===s)return!1;n.splice(s,1)}return!0}async function u(t){if("player"===t.currentActorPath)t.currentActorPath="opponents.0";else{const e=parseInt(t.currentActorPath.split(".")[1],10);e<t.opponents.length-1?t.currentActorPath=`opponents.${e+1}`:t.currentActorPath="player"}return t}async function m(e,n){const{card:s,diceValues:a}=e,i=s.matches[n],c=t(e,e.currentActorPath);if(!p(i.dice,c.dice))return e;i.dice.forEach((t=>{const e=c.dice.indexOf(t);-1!==e&&c.dice.splice(e,1)}));let o=[];i.rewards.forEach((t=>{const{name:e}=t,n=Array.isArray(t.delta)?t.delta:[t.delta],s=n[Math.floor(Math.random()*n.length)];c[e]+=s,o.push(`${s} ${e}`)}));const r=o.join(", ");i.claimedBy=e.currentActorPath,e.gameLog.push({season:e.seasonCount,actorPath:e.currentActorPath,description:`${c.name} spent ${i.dice.map((t=>a[t])).join(", ")} resources to claim "${i.description}" and received "${r}".`}),await u(e)}customElements.define("dice-list",h);class f extends HTMLElement{connectedCallback(){this.addEventListener("click",this.handleClick)}disconnectedCallback(){this.removeEventListener("click",this.handleClick)}renderMatchList(e){const{diceValues:n}=e,s=e.player.dice,{matches:a}=e.card;this.querySelector(".match-list").innerHTML=a.map((a=>`<div class="match" data-key=${a.key}>\n      <dt>${a.name}</dt>\n      <dd>${a.description}</dd>\n      <div class="flex space-between">\n        <dice-list \n          values="${a.dice.map((t=>n[t])).join(",")}" \n          selected="${s.map((t=>n[t])).join(",")}"\n        ></dice-list>\n        ${!1!==a.claimedBy?`<div>\n              Claimed by ${t(e,a.claimedBy)?.name}\n            </div>`:`<button \n               type="button" \n               ${p(a.dice,e.player.dice)?"":"disabled"}\n             >Claim</button>`}\n      </div>\n    </div>`)).join("")}render(t){if(!t)return this.innerHTML="\x3c!-- No State --\x3e";const{name:e,description:n}=t.card;this.innerHTML=`\n      <h2>${e}</h2>\n      <p>${n}</p>\n      <div class="match-list"></div>\n      <button type="button">Finish Season</button>\n    `,this.renderMatchList(t)}handleClick(t){const{target:e}=t,n=e.closest(".match"),s="BUTTON"===e.tagName,{key:a}=n.dataset;if(s)return async function(t){await i((async e=>{await m(e,t)}))}(a)}}customElements.define("panel-card",f);class y extends HTMLElement{render(t){const{gameLog:e}=t;if(!this.querySelector("h2")){const t=document.createElement("h2");t.textContent="Action Log",this.appendChild(t)}const n=this.querySelectorAll(".log-entry");if(e.length>n.length)for(let t=n.length;t<e.length;t++){const n=document.createElement("div");n.classList.add("log-entry"),e[t].actorPath.includes("player")?n.classList.add("player"):n.classList.add("opponent"),n.textContent=e[t].description,this.appendChild(n)}}}async function v(){await i((async e=>{await async function(e){const n=t(e,e.currentActorPath),s=e.card.matches.filter((t=>!1===t.claimedBy&&p(t.dice,n.dice)));if(!s.length)return await u(e);const a=s[Math.floor(Math.random()*s.length)];await m(e,a.key),await u(e)}(e)}))}customElements.define("panel-info",y);class $ extends HTMLElement{constructor(){super(),this.onTimeout=this.onTimeout.bind(this)}render(t){const{currentActorPath:e,dispatch:n}=t;e.includes("opponents")?(this.classList.remove("hide"),setTimeout(this.onTimeout,1e3)):this.classList.add("hide"),this.innerHTML='\n      <div class="opponent-panel">\n        <h1 class="opponent-title">Opponent\'s Turn</h1>\n        <div class="opponent-content">\n          <p>Opponent is thinking...</p>\n          <div class="loader"></div>\n        </div>\n      </div>\n    '}onTimeout(){v()}}customElements.define("panel-opponent",$);class w extends HTMLElement{render(t){const{name:e,diceValues:n,currentActorPath:s}=t,{food:a,morale:i,population:c,water:o}=t.player,r="player"===s,l=t.player.dice.map((t=>n[t]));r?this.classList.remove("hide"):this.classList.add("hide"),this.innerHTML=`\n    <div class="player-status">\n      <h2>${e} Tribe</h2>\n      <h3>Population: ${c}</h3>\n\n      <table class="stats-table">\n        <tbody>\n          <tr class="stat-item">\n            <td class="icon">üçî</td>\n            <td class="label">Food:</td>\n            <td class="value">${a}</td>\n          </tr>\n          \n          <tr class="stat-item">\n            <td class="icon">üíß</td>\n            <td class="label">Water:</td>\n            <td class="value">${o}</td>\n          </tr>\n\n          <tr class="stat-item">\n            <td class="icon">üòÄ</td>\n            <td class="label">Morale:</td>\n            <td class="value">${i}/100</td>\n          </tr>\n\n          <tr class="stat-item">\n            <td class="icon">üé≤</td>\n            <td class="label">Dice:</td>\n            <td class="value"><dice-list values="${l}" selected="${l}"></dice-list></td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n    `}}customElements.define("panel-player",w);const{elmScenarioPicker:b}=window,g=await n("tribes/index.json");b.options=g,window.elmScenarioPicker.addEventListener(o,(async t=>{!async function(t){await i((async e=>{await s(e,t)}))}(t.detail)}));
